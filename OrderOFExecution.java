//It demonstrates the order in which Java statements are executed and also tells about static methods
/* a)Static Variables are initialized
 * b)Static block in the written order
 * c)main methods
 * Y static methods: -- mainly for code sharing for instance methods
  1.Its often valuable when you know something is not going to change across instances
  2. "does it make sense to call this method, even if no Obj has been constructed yet?" If so, it should definitely be static.
  3. If you are writing utility classes and they are not supposed to be changed.
  4.If the method is not using any instance variable.
  5.If any operation is not dependent on instance creation.
  6.If there is some code that can easily be shared by all the instance methods, extract that code into a static method.
  7.If you are sure that the definition of the method will never be changed or overridden. As static methods can not be overridden.
  8.A compiler will usually produce slightly more efficient code because no implicit object parameter has to be passed to the method.
 *  default constructor
 * d) Non-static blocks in the order they are written
 * Y non static blocks
  1. If you have multiple constructors an initializer block which is common for all constructors is written in-order to avoid duplication
 * e) Constructors
 * f) normal flow as per main
 *  */
/* points to remember
 * In-order to make a non-static reference from a static method, an object is to be declared, 
 * method call is made like obj.method();
 * A superclass constructor is called before the 
 */
/*What actually happens with the constructor is that the runtime uses type data generated by the compiler 
 * to determine how much space is needed to store an object instance in memory, 
 * be it on the stack or on the heap. This space includes all members variables and the vtbl. 
 * After this space is allocated, the constructor is called as an internal part of the 
 * instantiation and initialization process to initialize the contents of the fields. 
 * Then, when the constructor exits, the runtime returns the newly-created instance. 
 * So the reason the constructor doesn't return a value is because it's not called directly by your code, 
 * it's called by the memory allocation and object initialization code in the runtime. Its return value (if 
 * it actually has one when compiled down to machine code) is opaque to the user - therefore, you can't specify it.
 */

public class OrderOFExecution {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("I am first statement in main");
		int t=1,b=2;
		System.out.println("I am Second statement in main");
		OrderOFExecution obj = new OrderOFExecution();//The new operator returns the newly created instance. 
		System.out.println("I am third statement in main");
		
		//System.out.println("I am a Constructor which returns an integer:"+a);
		obj.test1();		
	}

	public   void test1() {
		a = OrderOFExecution();
		System.out.println("I a non-static method which receives its value from parameterized constructor"+a);
	}

	static int a=50;
	int abc=50;
	

	{		System.out.println("I am a non-static block"); }
	
	int OrderOFExecution()
	{
		 a=20;
		 System.out.println("I am method which has the constructor name and I  return an integer"+abc);
		return a;
	}
	
	OrderOFExecution() { System.out.println("I am default Constructor");}
	
	static {			System.out.println("I am static block");}
		
	{		System.out.println("I am a non-static block"); }
		
	static {			System.out.println("I am static block 2"); }
	
	
	public  static void test2() {		
			System.out.println("Static Method");
			OrderOFExecution obj = new OrderOFExecution();
			obj.test1();
	}
	
}
